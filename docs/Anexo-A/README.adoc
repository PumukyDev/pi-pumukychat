=== Gestión de solicitudes

Para poder acceder a mi página web (`pumukydev.com`), es necesario un servidor DNS que actualice cuál es mi IP pública. De este modo, se puede acceder al sitio sin conocer manualmente la IP, ya que el dominio apunta siempre a la dirección correcta.

Este sistema de DNS dinámico está desplegado mediante un `docker-compose` que se encarga exclusivamente de mantener mi infraestructura accesible en todo momento. Dicho `docker-compose` está compuesto por dos contenedores:

* *DNS*: contiene un `cronjob` que ejecuta un script en Bash. Este script lanza una petición POST al servidor de IONOS cada minuto, con el objetivo de mantener actualizada la IP asociada a mis dominios.

[source,shell]
----
#!/bin/bash

source /etc/environment

# Make a POST request to the IONOS API to update the Dynamic DNS
# Then, store the response in 'output'
output=$(/usr/bin/curl -X 'POST' \
  'https://api.hosting.ionos.com/dns/v1/dyndns' \
  -H "accept: application/json" \
  -H "X-API-Key: $ID.$SecretKey" \
  -H "Content-Type: application/json" \
  -d '{
  "domains": [
    "pumukydev.com",
    "www.pumukydev.com",
    "stream.pumukydev.com",
    "chat.pumukydev.com"
  ],
  "description": "Dynamic DNS"
}')

# Extract the 'updateUrl' from the JSON response using jq
updateUrl=$(echo "$output" | /usr/bin/jq -r '.updateUrl')

/usr/bin/curl -f $updateUrl
----

* *NGINX Proxy*: se encarga de recibir las solicitudes externas y redirigirlas al servidor web correspondiente. En el caso del subdominio `chat.pumukydev.com`, todas las peticiones se derivan al contenedor `nginx_chat`. Si la solicitud termina en `/app`, se trata de una conexión WebSocket y se redirige al contenedor `reverb_chat`, responsable de Laravel Reverb.

[source,nginx]
----
server {
    listen 80;
    server_name pumukydev.com stream.pumukydev.com chat.pumukydev.com;

    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl;
    server_name X.pumukydev.com;

    ...
}

server {
    listen 443 ssl;
    server_name chat.pumukydev.com;

    ssl_certificate /etc/nginx/certs/fullchain.pem;
    ssl_certificate_key /etc/nginx/certs/_.pumukydev.com_private_key.key;

    client_max_body_size 500M;

    location / {
        proxy_pass http://nginx_chat:80;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;

        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto https;
    }
}
----

Todo esto se despliega a través del siguiente archivo `docker-compose.yml`:

[source,yaml]
----
services:
  nginx_proxy:
    build: ./nginx
    container_name: nginx_proxy
    restart: unless-stopped
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf.d/default.conf:/etc/nginx/conf.d/default.conf
      - ./nginx/certs/:/etc/nginx/certs/
    networks:
      - proxy-network

  dyndns:
    build: ./dynamic-dns
    container_name: dyndns
    restart: unless-stopped

networks:
  proxy-network:
    external: true
----

Además, el contenedor `nginx_proxy` necesita saber que los servicios a los que va a redirigir están disponibles antes de arrancar correctamente. Para ello, utilizo un script en Bash que emplea `netcat` (`nc`) para comprobar si los servicios están escuchando en sus respectivos puertos:

[source,shell]
----
#!/bin/sh

# wait-for-it.sh
# Waits for a list of host:port pairs to become available

set -e

PROXIED_TARGETS="${PROXIED_TARGETS:-nginx_chat:80 nginx_streaming:80}"
TIMEOUT="${TIMEOUT:-60}"

echo "[wait-for-it] Starting health checks..."

for target in $PROXIED_TARGETS; do
  host=$(echo "$target" | cut -d: -f1)
  port=$(echo "$target" | cut -d: -f2)

  echo "[wait-for-it] Checking $host:$port..."

  start_time=$(date +%s)
  while ! nc -z "$host" "$port"; do
    sleep 1
    now=$(date +%s)
    elapsed=$((now - start_time))

    if [ "$elapsed" -ge "$TIMEOUT" ]; then
      echo "[wait-for-it] ERROR: Timeout reached while waiting for $host:$port (${TIMEOUT}s)"
      exit 1
    fi
  done

  echo "[wait-for-it] $host:$port is available."
done

echo "[wait-for-it] All targets are ready. Proceeding..."
exec "$@"
----
